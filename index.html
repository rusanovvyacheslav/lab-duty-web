<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Lab Duty — Chat</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: light dark; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 0; padding: 16px; }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    .col { display: flex; flex-direction: column; gap: 8px; }
    .hidden { display: none !important; }
    .btn { padding: 8px 12px; border: 1px solid #8884; border-radius: 8px; cursor: pointer; }
    .btn[disabled] { opacity: .5; cursor: not-allowed; }
    .tag { display: inline-block; padding: 2px 8px; border: 1px solid #8884; border-radius: 999px; font-size: 12px; }
    .card { border: 1px solid #8884; border-radius: 12px; padding: 12px; margin: 8px 0; }
    .meta { font-size: 12px; opacity: .7; display:flex; gap:8px; flex-wrap: wrap; }
    .resolved { background: #15a34a22; } /* зелёная подсветка */
    .error { color: #b91c1c; font-size: 12px; margin: 4px 0; }
    .ok { color: #15803d; font-size: 12px; margin: 4px 0; }
    .hr { height:1px; background:#8884; margin:12px 0; }
    input[type="text"], input[type="date"], textarea, select {
      padding: 8px; border:1px solid #8884; border-radius:8px; min-width: 220px;
      background: transparent; color: inherit;
    }
    textarea { width: 100%; min-height: 80px; }
    .chips { display:flex; gap:6px; flex-wrap: wrap; }
  </style>
</head>
<body>

  <h1>Lab Duty — Chat</h1>

  <div id="authBox" class="card">
    <div class="row">
      <div class="col">
        <div><b>Вход</b></div>
        <input id="email" type="text" placeholder="email@example.com" />
        <input id="password" type="password" placeholder="Пароль" />
        <div class="row">
          <button id="btnSignIn" class="btn">Войти</button>
          <button id="btnRegister" class="btn">Регистрация</button>
          <button id="btnSignOut" class="btn" disabled>Выйти</button>
        </div>
        <div id="authMsg" class="error"></div>
      </div>

      <div class="col">
        <div><b>Текущий пользователь</b></div>
        <div id="whoami">—</div>
        <div class="chips">
          <span id="chipAdmin" class="tag hidden">admin</span>
          <span id="chipTeam" class="tag hidden"></span>
        </div>
      </div>
    </div>
  </div>

  <div id="adminBox" class="card hidden">
    <div class="row" style="justify-content: space-between;">
      <div class="col">
        <div><b>Админ-панель</b></div>
        <div class="meta">Админ видит все сообщения и может публиковать "от имени".</div>
      </div>
      <div class="col">
        <label>Публиковать от имени профиля:</label>
        <select id="postAsSelect">
          <option value="">— не выбрано —</option>
        </select>
        <div class="meta" id="postAsHint">Не выбрано — публикуется от вашего имени (как у обычного пользователя).</div>
      </div>
    </div>
  </div>

  <div class="card">
    <div><b>Отправить обычное сообщение</b></div>
    <textarea id="msgText" placeholder="Сообщение…" ></textarea>
    <div class="row">
      <button id="btnPublish" class="btn" disabled>Publish</button>
      <span class="meta">Видимость: ваша команда</span>
    </div>
    <div id="pubMsg" class="ok"></div>
  </div>

  <div class="card">
    <div><b>Swap offer</b></div>
    <div class="row">
      <div class="col">
        <label>От (teamId):</label>
        <input id="swapFrom" type="text" placeholder="vanina" />
      </div>
      <div class="col">
        <label>Кому (teamId):</label>
        <input id="swapTo" type="text" placeholder="slava" />
      </div>
      <div class="col">
        <label>Моя дата (YYYY-MM-DD):</label>
        <input id="swapDate" type="date" />
      </div>
      <div class="col">
        <label>Предлагаю на дату (YYYY-MM-DD):</label>
        <input id="swapAskDate" type="date" />
      </div>
    </div>
    <div class="row">
      <button id="btnSwapOffer" class="btn">Отправить swap offer</button>
      <span class="meta">Видимость: обе команды (from/to)</span>
    </div>
    <div id="swapMsg" class="ok"></div>
  </div>

  <div class="card">
    <div><b>Submit checklist</b></div>
    <div class="col">
      <label><input type="checkbox" class="chk" /> Пункт 1</label>
      <label><input type="checkbox" class="chk" /> Пункт 2</label>
      <label><input type="checkbox" class="chk" /> Пункт 3</label>
    </div>
    <div class="row">
      <button id="btnSubmitChecklist" class="btn">Submit checklist</button>
      <span class="meta">Все пункты обязаны быть отмечены</span>
    </div>
    <div id="chkMsg" class="ok"></div>
  </div>

  <div class="card">
    <div class="row" style="justify-content: space-between;">
      <b>Сообщения</b>
      <div class="meta" id="feedInfo">—</div>
    </div>
    <div id="feed"></div>
    <div id="feedErr" class="error"></div>
  </div>

  <script type="module">
    // ---------- Firebase SDK (v10 modular) ----------
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
    import {
      getAuth, onAuthStateChanged, signInWithEmailAndPassword,
      createUserWithEmailAndPassword, signOut
    } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js";
    import {
      getFirestore, doc, getDoc, setDoc, updateDoc,
      serverTimestamp, addDoc, collection, query, orderBy, limit,
      where, onSnapshot, collectionGroup
    } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";

    // ---- CONFIG (замените на свои значения) ----
    const firebaseConfig = {
      apiKey: "YOUR_API_KEY",
      authDomain: "YOUR_PROJECT.firebaseapp.com",
      projectId: "YOUR_PROJECT",
      storageBucket: "YOUR_PROJECT.appspot.com",
      messagingSenderId: "YOUR_SENDER_ID",
      appId: "YOUR_APP_ID"
    };

    // ---------- Init ----------
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    // ---------- UI refs ----------
    const whoami = document.getElementById('whoami');
    const chipAdmin = document.getElementById('chipAdmin');
    const chipTeam = document.getElementById('chipTeam');
    const authMsg = document.getElementById('authMsg');
    const btnSignIn = document.getElementById('btnSignIn');
    const btnRegister = document.getElementById('btnRegister');
    const btnSignOut = document.getElementById('btnSignOut');

    const adminBox = document.getElementById('adminBox');
    const postAsSelect = document.getElementById('postAsSelect');
    const postAsHint = document.getElementById('postAsHint');

    const msgText = document.getElementById('msgText');
    const btnPublish = document.getElementById('btnPublish');
    const pubMsg = document.getElementById('pubMsg');

    const swapFrom = document.getElementById('swapFrom');
    const swapTo = document.getElementById('swapTo');
    const swapDate = document.getElementById('swapDate');
    const swapAskDate = document.getElementById('swapAskDate');
    const btnSwapOffer = document.getElementById('btnSwapOffer');
    const swapMsg = document.getElementById('swapMsg');

    const btnSubmitChecklist = document.getElementById('btnSubmitChecklist');
    const chkMsg = document.getElementById('chkMsg');

    const email = document.getElementById('email');
    const password = document.getElementById('password');

    const feed = document.getElementById('feed');
    const feedErr = document.getElementById('feedErr');
    const feedInfo = document.getElementById('feedInfo');

    // ---------- State ----------
    let currentUser = null;
    let currentProfile = null; // {uid, name, teamId, isAdmin}
    let unsubFeed = null;
    let allProfiles = []; // для админа

    // ---------- Helpers ----------
    const nowMs = () => Date.now();
    const fmtDate = (ts) => {
      try {
        if (!ts) return '—';
        if (typeof ts.toDate === 'function') return ts.toDate().toLocaleString();
        return new Date(ts).toLocaleString();
      } catch { return '—'; }
    };
    const el = (html) => {
      const d = document.createElement('div'); d.innerHTML = html.trim(); return d.firstChild;
    };
    const setHidden = (node, hidden) => node.classList.toggle('hidden', hidden);

    // ---------- Auth UI ----------
    btnSignIn.onclick = async () => {
      authMsg.textContent = '';
      try {
        await signInWithEmailAndPassword(auth, email.value.trim(), password.value.trim());
      } catch (e) { authMsg.textContent = e.message; }
    };
    btnRegister.onclick = async () => {
      authMsg.textContent = '';
      try {
        const cred = await createUserWithEmailAndPassword(auth, email.value.trim(), password.value.trim());
        // создать профиль по умолчанию
        await setDoc(doc(db, 'profiles', cred.user.uid), {
          uid: cred.user.uid,
          name: cred.user.email.split('@')[0],
          teamId: 'unknown',
          isAdmin: false,
          createdAt: serverTimestamp()
        });
      } catch (e) { authMsg.textContent = e.message; }
    };
    btnSignOut.onclick = async () => { await signOut(auth); };

    // ---------- Profiles cache for admin ----------
    async function loadAllProfiles() {
      // Простая загрузка через REST getDoc нельзя; тут для краткости выберем по id, если они известны.
      // Для полноценного списка — сделайте отдельную коллекцию индекса или страничный вывод.
      // Для демо мы попробуем взять самых нужных — текущего и адресатов из настроек UI.
      // (Упростим: заполним select только текущим пользователем — вы можете заменить на свой способ.)
      allProfiles = [currentProfile].filter(Boolean);
      // Вы можете сами наполнить options нужными профилями:
      postAsSelect.innerHTML = '<option value="">— не выбрано —</option>';
      for (const p of allProfiles) {
        const opt = document.createElement('option');
        opt.value = p.uid;
        opt.textContent = `${p.name} (${p.teamId})`;
        postAsSelect.appendChild(opt);
      }
    }

    // ---------- Current profile ----------
    async function fetchProfile(uid) {
      const snap = await getDoc(doc(db, 'profiles', uid));
      if (!snap.exists()) return null;
      const data = snap.data();
      return {
        uid,
        name: data.name || '(no-name)',
        teamId: data.teamId || 'unknown',
        isAdmin: !!data.isAdmin
      };
    }

    function renderWhoAmI() {
      if (!currentUser) {
        whoami.textContent = '—';
        setHidden(chipAdmin, true);
        setHidden(chipTeam, true);
        setHidden(adminBox, true);
        btnSignOut.disabled = true;
        return;
      }
      whoami.textContent = `${currentUser.email} ${currentProfile ? `— ${currentProfile.name}` : ''}`;
      btnSignOut.disabled = false;
      if (currentProfile) {
        chipTeam.textContent = currentProfile.teamId;
        setHidden(chipTeam, false);
        setHidden(chipAdmin, !currentProfile.isAdmin);
        setHidden(adminBox, !currentProfile.isAdmin);
      }
    }

    // ---------- Messages feed ----------
    function unsubscribeFeed() { if (unsubFeed) { unsubFeed(); unsubFeed = null; } }

    function subscribeFeedForUser() {
      if (!currentProfile) return;
      unsubFeed && unsubFeed();

      // обычный пользователь видит все сообщения, где его teamId в visibleTeamIds
      const q = query(
        collectionGroup(db, 'messages'),
        where('visibleTeamIds', 'array-contains', currentProfile.teamId),
        orderBy('createdAt', 'desc'),
        limit(100)
      );

      feedInfo.textContent = `Фильтр: teamId=${currentProfile.teamId}`;
      feedErr.textContent = '';
      unsubFeed = onSnapshot(q, (snap) => {
        renderFeed(snap.docs.map(d => ({ id: d.id, ...d.data() })));
      }, (err) => {
        console.error('messages(user) onSnapshot error', err);
        feedErr.textContent = `messages(user) error: ${err.message}`;
      });
    }

    function subscribeFeedForAdmin() {
      if (!currentProfile || !currentProfile.isAdmin) return;
      unsubFeed && unsubFeed();

      // админ видит всё
      const q = query(
        collectionGroup(db, 'messages'),
        orderBy('createdAt', 'desc'),
        limit(200)
      );

      feedInfo.textContent = 'Фильтр: admin (все сообщения)';
      feedErr.textContent = '';
      unsubFeed = onSnapshot(q, (snap) => {
        renderFeed(snap.docs.map(d => ({ id: d.id, ...d.data() })));
      }, (err) => {
        console.error('messages(admin) onSnapshot error', err);
        feedErr.textContent = `messages(admin) error: ${err.message}`;
      });
    }

    function renderFeed(items) {
      feed.innerHTML = '';
      if (!items.length) {
        feed.appendChild(el(`<div class="meta">Пока сообщений нет</div>`));
        return;
      }
      for (const m of items) {
        if (m.status && m.status === 'cancelled') continue; // скрываем отменённые swap'ы

        const resolved = !!m.resolvedAt;
        const row = el(`<div class="card ${resolved ? 'resolved' : ''}">
          <div style="display:flex; justify-content:space-between; gap:8px; align-items:start;">
            <div>
              <div><b>${escapeHtml(m.kind || 'user')}</b></div>
              <div class="meta">
                <span>at: ${fmtDate(m.createdAt)}</span>
                ${m.authorName ? `<span>by: ${escapeHtml(m.authorName)}</span>` : ''}
                ${m.authorTeamId ? `<span>team: ${escapeHtml(m.authorTeamId)}</span>` : ''}
                ${m.postedByAdmin ? `<span class="tag">posted by admin</span>` : ''}
              </div>
            </div>
            <div class="chips">
              ${resolved ? `<span class="tag">resolved</span>` : ''}
              ${m.kind === 'swap_offer' && m.meta
                ? `<span class="tag">from: ${escapeHtml(m.meta.from)}</span>
                   <span class="tag">to: ${escapeHtml(m.meta.to)}</span>`
                : ''}
            </div>
          </div>
          <div style="margin-top:8px; white-space:pre-wrap;">${escapeHtml(m.text || '')}</div>
          <div class="hr"></div>
          <div class="row">
            <button class="btn btn-resolve">Mark resolved</button>
            ${currentProfile?.isAdmin || currentUser?.uid === m.authorId ? `<button class="btn btn-delete">Delete</button>` : ''}
          </div>
        </div>`);

        row.querySelector('.btn-resolve').onclick = () => markResolved(m);
        const delBtn = row.querySelector('.btn-delete');
        if (delBtn) delBtn.onclick = () => deleteMessage(m);
        feed.appendChild(row);
      }
    }

    function escapeHtml(s) {
      return String(s ?? '')
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;');
    }

    // ---------- Publish controls ----------
    msgText.addEventListener('input', () => {
      btnPublish.disabled = msgText.value.trim().length === 0;
    });

    btnPublish.onclick = async () => {
      pubMsg.textContent = '';
      try {
        await publishUserMessage(msgText.value.trim());
        msgText.value = '';
        btnPublish.disabled = true;
        pubMsg.textContent = 'Опубликовано';
        setTimeout(() => pubMsg.textContent = '', 1500);
      } catch (e) {
        pubMsg.textContent = e.message;
      }
    };

    async function publishUserMessage(text) {
      if (!currentUser || !currentProfile) throw new Error('Не авторизован');
      const postAsUid = postAsSelect.value; // если админ выбрал "от имени"
      let author = currentProfile;

      if (currentProfile.isAdmin && postAsUid) {
        // публикуем от имени выбранного профиля
        const ap = allProfiles.find(p => p.uid === postAsUid) || await fetchProfile(postAsUid);
        if (!ap) throw new Error('Выбранный профиль не найден');
        author = ap;
      }

      const path = ['teams', author.teamId, 'messages']; // пример размещения
      const ref = collection(db, ...path);

      const docData = {
        kind: 'user',
        text,
        createdAt: serverTimestamp(),
        createdAtMs: nowMs(),

        // "содержательный" автор
        authorId: author.uid,
        authorName: author.name,
        authorTeamId: author.teamId,

        // кто реально постит
        postedByAdmin: currentProfile.isAdmin && !!postAsUid,
        postedByAdminId: currentUser.uid,
        postedByAdminName: currentProfile.name,

        // видимость
        visibleTeamIds: [author.teamId],

        meta: {},
        resolvedAt: null
      };

      await addDoc(ref, docData);
    }

    // ---------- Swap offer ----------
    btnSwapOffer.onclick = async () => {
      swapMsg.textContent = '';
      try {
        await sendSwapOffer({
          from: swapFrom.value.trim(),
          to: swapTo.value.trim(),
          date: swapDate.value,
          askDate: swapAskDate.value
        });
        swapMsg.textContent = 'Swap offer отправлен';
        setTimeout(() => swapMsg.textContent = '', 1500);
      } catch (e) {
        swapMsg.textContent = e.message;
      }
    };

    async function sendSwapOffer({ from, to, date, askDate }) {
      if (!currentUser || !currentProfile) throw new Error('Не авторизован');

      if (!from || !to || !date || !askDate) throw new Error('Заполните все поля swap');
      // Автор по смыслу — тот, от чьего имени отправляем
      let author = currentProfile;
      const postAsUid = currentProfile.isAdmin ? postAsSelect.value : '';
      if (currentProfile.isAdmin && postAsUid) {
        const ap = allProfiles.find(p => p.uid === postAsUid) || await fetchProfile(postAsUid);
        if (!ap) throw new Error('Выбранный профиль не найден');
        author = ap;
      }

      // Текст сообщения
      const text = `🔁 Swap offer: ${author.name} proposes exchange ${date} ⇄ ${askDate}`;

      // Размещаем в удобном для вас месте; важно что коллекция называется "messages"
      const ref = collection(db, 'teams', from, 'messages');

      const docData = {
        kind: 'swap_offer',
        text,
        createdAt: serverTimestamp(),
        createdAtMs: nowMs(),

        authorId: author.uid,
        authorName: author.name,
        authorTeamId: author.teamId,

        postedByAdmin: currentProfile.isAdmin && !!postAsUid,
        postedByAdminId: currentUser.uid,
        postedByAdminName: currentProfile.name,

        // ВАЖНО: обе команды в видимости
        visibleTeamIds: Array.from(new Set([from, to])),

        meta: { from, to, date, askDate },
        status: 'open',       // open | accepted | declined | counter | cancelled
        resolvedAt: null
      };

      await addDoc(ref, docData);
    }

    // ---------- Checklist ----------
    btnSubmitChecklist.onclick = async () => {
      chkMsg.textContent = '';
      try {
        const all = [...document.querySelectorAll('.chk')];
        const allChecked = all.every(c => c.checked);
        if (!allChecked) throw new Error('Отметьте все пункты чек-листа');

        await publishChecklistSubmitted();
        chkMsg.textContent = 'Checklist отправлен в чат';
        setTimeout(() => chkMsg.textContent = '', 1500);
      } catch (e) {
        chkMsg.textContent = e.message;
      }
    };

    async function publishChecklistSubmitted() {
      if (!currentUser || !currentProfile) throw new Error('Не авторизован');

      let author = currentProfile;
      const postAsUid = currentProfile.isAdmin ? postAsSelect.value : '';
      if (currentProfile.isAdmin && postAsUid) {
        const ap = allProfiles.find(p => p.uid === postAsUid) || await fetchProfile(postAsUid);
        if (!ap) throw new Error('Выбранный профиль не найден');
        author = ap;
      }

      const ref = collection(db, 'teams', author.teamId, 'messages');

      const docData = {
        kind: 'checklist_submitted',
        text: '✅ Checklist submitted',
        createdAt: serverTimestamp(),
        createdAtMs: nowMs(),

        authorId: author.uid,
        authorName: author.name,
        authorTeamId: author.teamId,

        postedByAdmin: currentProfile.isAdmin && !!postAsUid,
        postedByAdminId: currentUser.uid,
        postedByAdminName: currentProfile.name,

        visibleTeamIds: [author.teamId],
        meta: {},
        resolvedAt: null
      };

      await addDoc(ref, docData);
    }

    // ---------- Mutations ----------
    async function markResolved(m) {
      try {
        const refPath = m._refPath || guessRefPath(m);
        if (!refPath) throw new Error('Невозможно определить путь документа');
        await updateDoc(doc(db, ...refPath), { resolvedAt: serverTimestamp() });
      } catch (e) {
        alert('Mark resolved error: ' + e.message);
      }
    }

    async function deleteMessage(m) {
      try {
        const refPath = m._refPath || guessRefPath(m);
        if (!refPath) throw new Error('Невозможно определить путь документа');
        // Мягкое удаление — меняем статус
        await updateDoc(doc(db, ...refPath), { status: 'cancelled' });
      } catch (e) {
        alert('Delete error: ' + e.message);
      }
    }

    // NOTE: когда слушаем collectionGroup, Firebase не отдаёт нам полный путь.
    // Простой способ «угадать» — если мы жестко знаем схему `teams/{teamId}/messages/{id}`:
    function guessRefPath(m) {
      const teamId = m.authorTeamId || (currentProfile?.teamId ?? null);
      if (!teamId) return null;
      // В collectionGroup нет info о коллекции-родителе; если документ лежит в другой команде, этот путь не сработает.
      // При желании сохраните `_parentPath` в самом документе при создании.
      return ['teams', teamId, 'messages', m.id];
    }

    // ---------- Auth state ----------
    onAuthStateChanged(auth, async (user) => {
      currentUser = user || null;
      unsubscribeFeed();
      if (!currentUser) {
        currentProfile = null;
        renderWhoAmI();
        feed.innerHTML = '';
        feedInfo.textContent = '—';
        postAsSelect.value = '';
        setHidden(adminBox, true);
        return;
      }
      currentProfile = await fetchProfile(currentUser.uid);
      renderWhoAmI();

      // Заполнить "post as" (минимум — свой профиль; вы можете расширить)
      await loadAllProfiles();

      // Подписка: если админ — показываем все; иначе — только по своей команде
      if (currentProfile.isAdmin) subscribeFeedForAdmin();
      else subscribeFeedForUser();
    });

    // Сброс "post as" при смене режима админа
    postAsSelect.addEventListener('change', () => {
      postAsHint.textContent = postAsSelect.value
        ? 'Сообщение будет опубликовано от имени выбранного профиля'
        : 'Не выбрано — публикуется от вашего имени (как у обычного пользователя).';
    });
  </script>
</body>
</html>
